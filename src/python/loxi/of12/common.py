# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
from . import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.of12']

class bsn_interface(loxi.OFObject):

    def __init__(self, hw_addr=None, name=None, ipv4_addr=None, ipv4_netmask=None):
        self.hw_addr = hw_addr if hw_addr != None else [0,0,0,0,0,0]
        self.name = name if name != None else ""
        self.ipv4_addr = ipv4_addr if ipv4_addr != None else 0
        self.ipv4_netmask = ipv4_netmask if ipv4_netmask != None else 0
        return

    def pack(self):
        packed = [struct.pack("!6B", *self.hw_addr), '\x00' * 2]
        packed.append(struct.pack("!16s", self.name))
        packed.append(struct.pack("!L", self.ipv4_addr))
        packed.append(struct.pack("!L", self.ipv4_netmask))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_interface()
        obj.hw_addr = list(reader.read('!6B'))
        reader.skip(2)
        obj.name = reader.read("!16s")[0].rstrip("\x00")
        obj.ipv4_addr = reader.read("!L")[0]
        obj.ipv4_netmask = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.hw_addr != other.hw_addr: return False
        if self.name != other.name: return False
        if self.ipv4_addr != other.ipv4_addr: return False
        return self.ipv4_netmask == other.ipv4_netmask

    def pretty_print(self, q):
        q.text("bsn_interface {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("hw_addr = ");
                q.text(util.pretty_mac(self.hw_addr))
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("ipv4_addr = ");
                q.text(util.pretty_ipv4(self.ipv4_addr))
                q.text(","); q.breakable()
                q.text("ipv4_netmask = ");
                q.text(util.pretty_ipv4(self.ipv4_netmask))
            q.breakable()
        q.text('}')


class bsn_vport(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        self.type = type if type != None else 0
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        if subclass := bsn_vport.subtypes.get(subtype):
            return subclass.unpack(reader)

        obj = bsn_vport()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        return False if type(self) != type(other) else self.type == other.type

    def pretty_print(self, q):
        q.text("bsn_vport {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class bsn_vport_l2gre(bsn_vport):
    type = 1

    def __init__(self, flags=None, port_no=None, loopback_port_no=None, local_mac=None, nh_mac=None, src_ip=None, dst_ip=None, dscp=None, ttl=None, vpn=None, rate_limit=None, if_name=None):
        self.flags = flags if flags != None else 0
        self.port_no = port_no if port_no != None else 0
        self.loopback_port_no = loopback_port_no if loopback_port_no != None else 0
        self.local_mac = local_mac if local_mac != None else [0,0,0,0,0,0]
        self.nh_mac = nh_mac if nh_mac != None else [0,0,0,0,0,0]
        self.src_ip = src_ip if src_ip != None else 0
        self.dst_ip = dst_ip if dst_ip != None else 0
        self.dscp = dscp if dscp != None else 0
        self.ttl = ttl if ttl != None else 0
        self.vpn = vpn if vpn != None else 0
        self.rate_limit = rate_limit if rate_limit != None else 0
        self.if_name = if_name if if_name != None else ""
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.flags))
        packed.append(util.pack_port_no(self.port_no))
        packed.append(util.pack_port_no(self.loopback_port_no))
        packed.append(struct.pack("!6B", *self.local_mac))
        packed.append(struct.pack("!6B", *self.nh_mac))
        packed.append(struct.pack("!L", self.src_ip))
        packed.append(struct.pack("!L", self.dst_ip))
        packed.append(struct.pack("!B", self.dscp))
        packed.extend((struct.pack("!B", self.ttl), '\x00' * 2))
        packed.append(struct.pack("!L", self.vpn))
        packed.append(struct.pack("!L", self.rate_limit))
        packed.append(struct.pack("!16s", self.if_name))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vport_l2gre()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.flags = reader.read("!L")[0]
        obj.port_no = util.unpack_port_no(reader)
        obj.loopback_port_no = util.unpack_port_no(reader)
        obj.local_mac = list(reader.read('!6B'))
        obj.nh_mac = list(reader.read('!6B'))
        obj.src_ip = reader.read("!L")[0]
        obj.dst_ip = reader.read("!L")[0]
        obj.dscp = reader.read("!B")[0]
        obj.ttl = reader.read("!B")[0]
        reader.skip(2)
        obj.vpn = reader.read("!L")[0]
        obj.rate_limit = reader.read("!L")[0]
        obj.if_name = reader.read("!16s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.flags != other.flags: return False
        if self.port_no != other.port_no: return False
        if self.loopback_port_no != other.loopback_port_no: return False
        if self.local_mac != other.local_mac: return False
        if self.nh_mac != other.nh_mac: return False
        if self.src_ip != other.src_ip: return False
        if self.dst_ip != other.dst_ip: return False
        if self.dscp != other.dscp: return False
        if self.ttl != other.ttl: return False
        if self.vpn != other.vpn: return False
        if self.rate_limit != other.rate_limit: return False
        return self.if_name == other.if_name

    def pretty_print(self, q):
        q.text("bsn_vport_l2gre {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("flags = ");
                value_name_map = {1: 'OF_BSN_VPORT_L2GRE_LOCAL_MAC_IS_VALID', 2: 'OF_BSN_VPORT_L2GRE_DSCP_ASSIGN', 4: 'OF_BSN_VPORT_L2GRE_DSCP_COPY', 8: 'OF_BSN_VPORT_L2GRE_LOOPBACK_IS_VALID', 16: 'OF_BSN_VPORT_L2GRE_RATE_LIMIT_IS_VALID'}
                q.text(util.pretty_flags(self.flags, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("loopback_port_no = ");
                q.text(util.pretty_port(self.loopback_port_no))
                q.text(","); q.breakable()
                q.text("local_mac = ");
                q.text(util.pretty_mac(self.local_mac))
                q.text(","); q.breakable()
                q.text("nh_mac = ");
                q.text(util.pretty_mac(self.nh_mac))
                q.text(","); q.breakable()
                q.text("src_ip = ");
                q.text(util.pretty_ipv4(self.src_ip))
                q.text(","); q.breakable()
                q.text("dst_ip = ");
                q.text(util.pretty_ipv4(self.dst_ip))
                q.text(","); q.breakable()
                q.text("dscp = ");
                q.text("%#x" % self.dscp)
                q.text(","); q.breakable()
                q.text("ttl = ");
                q.text("%#x" % self.ttl)
                q.text(","); q.breakable()
                q.text("vpn = ");
                q.text("%#x" % self.vpn)
                q.text(","); q.breakable()
                q.text("rate_limit = ");
                q.text("%#x" % self.rate_limit)
                q.text(","); q.breakable()
                q.text("if_name = ");
                q.pp(self.if_name)
            q.breakable()
        q.text('}')

bsn_vport.subtypes[1] = bsn_vport_l2gre

class bsn_vport_q_in_q(bsn_vport):
    type = 0

    def __init__(self, port_no=None, ingress_tpid=None, ingress_vlan_id=None, egress_tpid=None, egress_vlan_id=None, if_name=None):
        self.port_no = port_no if port_no != None else 0
        self.ingress_tpid = ingress_tpid if ingress_tpid != None else 0
        self.ingress_vlan_id = ingress_vlan_id if ingress_vlan_id != None else 0
        self.egress_tpid = egress_tpid if egress_tpid != None else 0
        self.egress_vlan_id = egress_vlan_id if egress_vlan_id != None else 0
        self.if_name = if_name if if_name != None else ""
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.port_no))
        packed.append(struct.pack("!H", self.ingress_tpid))
        packed.append(struct.pack("!H", self.ingress_vlan_id))
        packed.append(struct.pack("!H", self.egress_tpid))
        packed.append(struct.pack("!H", self.egress_vlan_id))
        packed.append(struct.pack("!16s", self.if_name))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_vport_q_in_q()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.port_no = reader.read("!L")[0]
        obj.ingress_tpid = reader.read("!H")[0]
        obj.ingress_vlan_id = reader.read("!H")[0]
        obj.egress_tpid = reader.read("!H")[0]
        obj.egress_vlan_id = reader.read("!H")[0]
        obj.if_name = reader.read("!16s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.ingress_tpid != other.ingress_tpid: return False
        if self.ingress_vlan_id != other.ingress_vlan_id: return False
        if self.egress_tpid != other.egress_tpid: return False
        if self.egress_vlan_id != other.egress_vlan_id: return False
        return self.if_name == other.if_name

    def pretty_print(self, q):
        q.text("bsn_vport_q_in_q {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text("%#x" % self.port_no)
                q.text(","); q.breakable()
                q.text("ingress_tpid = ");
                q.text("%#x" % self.ingress_tpid)
                q.text(","); q.breakable()
                q.text("ingress_vlan_id = ");
                q.text("%#x" % self.ingress_vlan_id)
                q.text(","); q.breakable()
                q.text("egress_tpid = ");
                q.text("%#x" % self.egress_tpid)
                q.text(","); q.breakable()
                q.text("egress_vlan_id = ");
                q.text("%#x" % self.egress_vlan_id)
                q.text(","); q.breakable()
                q.text("if_name = ");
                q.pp(self.if_name)
            q.breakable()
        q.text('}')

bsn_vport.subtypes[0] = bsn_vport_q_in_q

class bucket(loxi.OFObject):

    def __init__(self, weight=None, watch_port=None, watch_group=None, actions=None):
        self.weight = weight if weight != None else 0
        self.watch_port = watch_port if watch_port != None else 0
        self.watch_group = watch_group if watch_group != None else 0
        self.actions = actions if actions != None else []
        return

    def pack(self):
        packed = [struct.pack("!H", 0)]
        packed.append(struct.pack("!H", self.weight))
        packed.append(util.pack_port_no(self.watch_port))
        packed.extend((struct.pack("!L", self.watch_group), '\x00' * 4))
        packed.append(loxi.generic_util.pack_list(self.actions))
        length = sum(len(x) for x in packed)
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bucket()
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 2)
        obj.weight = reader.read("!H")[0]
        obj.watch_port = util.unpack_port_no(reader)
        obj.watch_group = reader.read("!L")[0]
        reader.skip(4)
        obj.actions = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.weight != other.weight: return False
        if self.watch_port != other.watch_port: return False
        if self.watch_group != other.watch_group: return False
        return self.actions == other.actions

    def pretty_print(self, q):
        q.text("bucket {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("weight = ");
                q.text("%#x" % self.weight)
                q.text(","); q.breakable()
                q.text("watch_port = ");
                q.text(util.pretty_port(self.watch_port))
                q.text(","); q.breakable()
                q.text("watch_group = ");
                q.text("%#x" % self.watch_group)
                q.text(","); q.breakable()
                q.text("actions = ");
                q.pp(self.actions)
            q.breakable()
        q.text('}')


class bucket_counter(loxi.OFObject):

    def __init__(self, packet_count=None, byte_count=None):
        self.packet_count = packet_count if packet_count != None else 0
        self.byte_count = byte_count if byte_count != None else 0
        return

    def pack(self):
        packed = [struct.pack("!Q", self.packet_count)]
        packed.append(struct.pack("!Q", self.byte_count))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bucket_counter()
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.packet_count != other.packet_count: return False
        return self.byte_count == other.byte_count

    def pretty_print(self, q):
        q.text("bucket_counter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
            q.breakable()
        q.text('}')


class flow_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, duration_sec=None, duration_nsec=None, priority=None, idle_timeout=None, hard_timeout=None, cookie=None, packet_count=None, byte_count=None, match=None, instructions=None):
        self.table_id = table_id if table_id != None else 0
        self.duration_sec = duration_sec if duration_sec != None else 0
        self.duration_nsec = duration_nsec if duration_nsec != None else 0
        self.priority = priority if priority != None else 0
        self.idle_timeout = idle_timeout if idle_timeout != None else 0
        self.hard_timeout = hard_timeout if hard_timeout != None else 0
        self.cookie = cookie if cookie != None else 0
        self.packet_count = packet_count if packet_count != None else 0
        self.byte_count = byte_count if byte_count != None else 0
        self.match = match if match != None else ofp.match()
        self.instructions = instructions if instructions != None else []
        return

    def pack(self):
        packed = [struct.pack("!H", 0)]
        packed.extend((struct.pack("!B", self.table_id), '\x00' * 1))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.extend((struct.pack("!H", self.hard_timeout), '\x00' * 6))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.packet_count))
        packed.append(struct.pack("!Q", self.byte_count))
        packed.append(self.match.pack())
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum(len(x) for x in packed)
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.table_id = reader.read("!B")[0]
        reader.skip(1)
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.priority = reader.read("!H")[0]
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        reader.skip(6)
        obj.cookie = reader.read("!Q")[0]
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        obj.match = ofp.match.unpack(reader)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.priority != other.priority: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.cookie != other.cookie: return False
        if self.packet_count != other.packet_count: return False
        if self.byte_count != other.byte_count: return False
        if self.match != other.match: return False
        return self.instructions == other.instructions

    def pretty_print(self, q):
        q.text("flow_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')


class group_desc_stats_entry(loxi.OFObject):

    def __init__(self, group_type=None, group_id=None, buckets=None):
        self.group_type = group_type if group_type != None else 0
        self.group_id = group_id if group_id != None else 0
        self.buckets = buckets if buckets != None else []
        return

    def pack(self):
        packed = [struct.pack("!H", 0)]
        packed.extend((struct.pack("!B", self.group_type), '\x00' * 1))
        packed.append(struct.pack("!L", self.group_id))
        packed.append(loxi.generic_util.pack_list(self.buckets))
        length = sum(len(x) for x in packed)
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_desc_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        obj.group_type = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        obj.buckets = loxi.generic_util.unpack_list(reader, ofp.common.bucket.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.group_type != other.group_type: return False
        if self.group_id != other.group_id: return False
        return self.buckets == other.buckets

    def pretty_print(self, q):
        q.text("group_desc_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("group_type = ");
                value_name_map = {0: 'OFPGT_ALL', 1: 'OFPGT_SELECT', 2: 'OFPGT_INDIRECT', 3: 'OFPGT_FF'}
                if self.group_type in value_name_map:
                    q.text("%s(%d)" % (value_name_map[self.group_type], self.group_type))
                else:
                    q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("buckets = ");
                q.pp(self.buckets)
            q.breakable()
        q.text('}')


class group_stats_entry(loxi.OFObject):

    def __init__(self, group_id=None, ref_count=None, packet_count=None, byte_count=None, bucket_stats=None):
        self.group_id = group_id if group_id != None else 0
        self.ref_count = ref_count if ref_count != None else 0
        self.packet_count = packet_count if packet_count != None else 0
        self.byte_count = byte_count if byte_count != None else 0
        self.bucket_stats = bucket_stats if bucket_stats != None else []
        return

    def pack(self):
        packed = [struct.pack("!H", 0), '\x00' * 2]
        packed.append(struct.pack("!L", self.group_id))
        packed.extend((struct.pack("!L", self.ref_count), '\x00' * 4))
        packed.append(struct.pack("!Q", self.packet_count))
        packed.append(struct.pack("!Q", self.byte_count))
        packed.append(loxi.generic_util.pack_list(self.bucket_stats))
        length = sum(len(x) for x in packed)
        packed[0] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_stats_entry()
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 2)
        reader.skip(2)
        obj.group_id = reader.read("!L")[0]
        obj.ref_count = reader.read("!L")[0]
        reader.skip(4)
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        obj.bucket_stats = loxi.generic_util.unpack_list(reader, ofp.common.bucket_counter.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.group_id != other.group_id: return False
        if self.ref_count != other.ref_count: return False
        if self.packet_count != other.packet_count: return False
        if self.byte_count != other.byte_count: return False
        return self.bucket_stats == other.bucket_stats

    def pretty_print(self, q):
        q.text("group_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("ref_count = ");
                q.text("%#x" % self.ref_count)
                q.text(","); q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
                q.text(","); q.breakable()
                q.text("bucket_stats = ");
                q.pp(self.bucket_stats)
            q.breakable()
        q.text('}')


class match_v3(loxi.OFObject):
    type = 1

    def __init__(self, oxm_list=None):
        self.oxm_list = oxm_list if oxm_list != None else []
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(loxi.generic_util.pack_list(self.oxm_list))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        packed.append(loxi.generic_util.pad_to(8, length))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = match_v3()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.oxm_list = loxi.generic_util.unpack_list(reader, ofp.oxm.oxm.unpack)
        orig_reader.skip_align()
        return obj

    def __eq__(self, other):
        return False if type(self) != type(other) else self.oxm_list == other.oxm_list

    def pretty_print(self, q):
        q.text("match_v3 {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("oxm_list = ");
                q.pp(self.oxm_list)
            q.breakable()
        q.text('}')


class packet_queue(loxi.OFObject):

    def __init__(self, queue_id=None, port=None, properties=None):
        self.queue_id = queue_id if queue_id != None else 0
        self.port = port if port != None else 0
        self.properties = properties if properties != None else []
        return

    def pack(self):
        packed = [struct.pack("!L", self.queue_id)]
        packed.append(util.pack_port_no(self.port))
        packed.extend((struct.pack("!H", 0), '\x00' * 6))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum(len(x) for x in packed)
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = packet_queue()
        obj.queue_id = reader.read("!L")[0]
        obj.port = util.unpack_port_no(reader)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 10)
        reader.skip(6)
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.common.queue_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.queue_id != other.queue_id: return False
        if self.port != other.port: return False
        return self.properties == other.properties

    def pretty_print(self, q):
        q.text("packet_queue {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("queue_id = ");
                q.text("%#x" % self.queue_id)
                q.text(","); q.breakable()
                q.text("port = ");
                q.text(util.pretty_port(self.port))
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')


class port_desc(loxi.OFObject):

    def __init__(self, port_no=None, hw_addr=None, name=None, config=None, state=None, curr=None, advertised=None, supported=None, peer=None, curr_speed=None, max_speed=None):
        self.port_no = port_no if port_no != None else 0
        self.hw_addr = hw_addr if hw_addr != None else [0,0,0,0,0,0]
        self.name = name if name != None else ""
        self.config = config if config != None else 0
        self.state = state if state != None else 0
        self.curr = curr if curr != None else 0
        self.advertised = advertised if advertised != None else 0
        self.supported = supported if supported != None else 0
        self.peer = peer if peer != None else 0
        self.curr_speed = curr_speed if curr_speed != None else 0
        self.max_speed = max_speed if max_speed != None else 0
        return

    def pack(self):
        packed = [util.pack_port_no(self.port_no), '\x00' * 4]
        packed.extend((struct.pack("!6B", *self.hw_addr), '\x00' * 2))
        packed.append(struct.pack("!16s", self.name))
        packed.append(struct.pack("!L", self.config))
        packed.append(struct.pack("!L", self.state))
        packed.append(struct.pack("!L", self.curr))
        packed.append(struct.pack("!L", self.advertised))
        packed.append(struct.pack("!L", self.supported))
        packed.append(struct.pack("!L", self.peer))
        packed.append(struct.pack("!L", self.curr_speed))
        packed.append(struct.pack("!L", self.max_speed))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_desc()
        obj.port_no = util.unpack_port_no(reader)
        reader.skip(4)
        obj.hw_addr = list(reader.read('!6B'))
        reader.skip(2)
        obj.name = reader.read("!16s")[0].rstrip("\x00")
        obj.config = reader.read("!L")[0]
        obj.state = reader.read("!L")[0]
        obj.curr = reader.read("!L")[0]
        obj.advertised = reader.read("!L")[0]
        obj.supported = reader.read("!L")[0]
        obj.peer = reader.read("!L")[0]
        obj.curr_speed = reader.read("!L")[0]
        obj.max_speed = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.hw_addr != other.hw_addr: return False
        if self.name != other.name: return False
        if self.config != other.config: return False
        if self.state != other.state: return False
        if self.curr != other.curr: return False
        if self.advertised != other.advertised: return False
        if self.supported != other.supported: return False
        if self.peer != other.peer: return False
        if self.curr_speed != other.curr_speed: return False
        return self.max_speed == other.max_speed

    def pretty_print(self, q):
        q.text("port_desc {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("hw_addr = ");
                q.text(util.pretty_mac(self.hw_addr))
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("config = ");
                value_name_map = {1: 'OFPPC_PORT_DOWN', 4: 'OFPPC_NO_RECV', 32: 'OFPPC_NO_FWD', 64: 'OFPPC_NO_PACKET_IN', 2147483648: 'OFPPC_BSN_MIRROR_DEST'}
                q.text(util.pretty_flags(self.config, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("state = ");
                value_name_map = {1: 'OFPPS_LINK_DOWN', 2: 'OFPPS_BLOCKED', 4: 'OFPPS_LIVE'}
                q.text(util.pretty_flags(self.state, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("curr = ");
                value_name_map = {1: 'OFPPF_10MB_HD', 2: 'OFPPF_10MB_FD', 4: 'OFPPF_100MB_HD', 8: 'OFPPF_100MB_FD', 16: 'OFPPF_1GB_HD', 32: 'OFPPF_1GB_FD', 64: 'OFPPF_10GB_FD', 128: 'OFPPF_40GB_FD', 256: 'OFPPF_100GB_FD', 512: 'OFPPF_1TB_FD', 1024: 'OFPPF_OTHER', 2048: 'OFPPF_COPPER', 4096: 'OFPPF_FIBER', 8192: 'OFPPF_AUTONEG', 16384: 'OFPPF_PAUSE', 32768: 'OFPPF_PAUSE_ASYM'}
                q.text(util.pretty_flags(self.curr, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("advertised = ");
                value_name_map = {1: 'OFPPF_10MB_HD', 2: 'OFPPF_10MB_FD', 4: 'OFPPF_100MB_HD', 8: 'OFPPF_100MB_FD', 16: 'OFPPF_1GB_HD', 32: 'OFPPF_1GB_FD', 64: 'OFPPF_10GB_FD', 128: 'OFPPF_40GB_FD', 256: 'OFPPF_100GB_FD', 512: 'OFPPF_1TB_FD', 1024: 'OFPPF_OTHER', 2048: 'OFPPF_COPPER', 4096: 'OFPPF_FIBER', 8192: 'OFPPF_AUTONEG', 16384: 'OFPPF_PAUSE', 32768: 'OFPPF_PAUSE_ASYM'}
                q.text(util.pretty_flags(self.advertised, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("supported = ");
                value_name_map = {1: 'OFPPF_10MB_HD', 2: 'OFPPF_10MB_FD', 4: 'OFPPF_100MB_HD', 8: 'OFPPF_100MB_FD', 16: 'OFPPF_1GB_HD', 32: 'OFPPF_1GB_FD', 64: 'OFPPF_10GB_FD', 128: 'OFPPF_40GB_FD', 256: 'OFPPF_100GB_FD', 512: 'OFPPF_1TB_FD', 1024: 'OFPPF_OTHER', 2048: 'OFPPF_COPPER', 4096: 'OFPPF_FIBER', 8192: 'OFPPF_AUTONEG', 16384: 'OFPPF_PAUSE', 32768: 'OFPPF_PAUSE_ASYM'}
                q.text(util.pretty_flags(self.supported, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("peer = ");
                value_name_map = {1: 'OFPPF_10MB_HD', 2: 'OFPPF_10MB_FD', 4: 'OFPPF_100MB_HD', 8: 'OFPPF_100MB_FD', 16: 'OFPPF_1GB_HD', 32: 'OFPPF_1GB_FD', 64: 'OFPPF_10GB_FD', 128: 'OFPPF_40GB_FD', 256: 'OFPPF_100GB_FD', 512: 'OFPPF_1TB_FD', 1024: 'OFPPF_OTHER', 2048: 'OFPPF_COPPER', 4096: 'OFPPF_FIBER', 8192: 'OFPPF_AUTONEG', 16384: 'OFPPF_PAUSE', 32768: 'OFPPF_PAUSE_ASYM'}
                q.text(util.pretty_flags(self.peer, value_name_map.values()))
                q.text(","); q.breakable()
                q.text("curr_speed = ");
                q.text("%#x" % self.curr_speed)
                q.text(","); q.breakable()
                q.text("max_speed = ");
                q.text("%#x" % self.max_speed)
            q.breakable()
        q.text('}')


class port_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, rx_packets=None, tx_packets=None, rx_bytes=None, tx_bytes=None, rx_dropped=None, tx_dropped=None, rx_errors=None, tx_errors=None, rx_frame_err=None, rx_over_err=None, rx_crc_err=None, collisions=None):
        self.port_no = port_no if port_no != None else 0
        self.rx_packets = rx_packets if rx_packets != None else 0
        self.tx_packets = tx_packets if tx_packets != None else 0
        self.rx_bytes = rx_bytes if rx_bytes != None else 0
        self.tx_bytes = tx_bytes if tx_bytes != None else 0
        self.rx_dropped = rx_dropped if rx_dropped != None else 0
        self.tx_dropped = tx_dropped if tx_dropped != None else 0
        self.rx_errors = rx_errors if rx_errors != None else 0
        self.tx_errors = tx_errors if tx_errors != None else 0
        self.rx_frame_err = rx_frame_err if rx_frame_err != None else 0
        self.rx_over_err = rx_over_err if rx_over_err != None else 0
        self.rx_crc_err = rx_crc_err if rx_crc_err != None else 0
        self.collisions = collisions if collisions != None else 0
        return

    def pack(self):
        packed = [util.pack_port_no(self.port_no), '\x00' * 4]
        packed.append(struct.pack("!Q", self.rx_packets))
        packed.append(struct.pack("!Q", self.tx_packets))
        packed.append(struct.pack("!Q", self.rx_bytes))
        packed.append(struct.pack("!Q", self.tx_bytes))
        packed.append(struct.pack("!Q", self.rx_dropped))
        packed.append(struct.pack("!Q", self.tx_dropped))
        packed.append(struct.pack("!Q", self.rx_errors))
        packed.append(struct.pack("!Q", self.tx_errors))
        packed.append(struct.pack("!Q", self.rx_frame_err))
        packed.append(struct.pack("!Q", self.rx_over_err))
        packed.append(struct.pack("!Q", self.rx_crc_err))
        packed.append(struct.pack("!Q", self.collisions))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_stats_entry()
        obj.port_no = util.unpack_port_no(reader)
        reader.skip(4)
        obj.rx_packets = reader.read("!Q")[0]
        obj.tx_packets = reader.read("!Q")[0]
        obj.rx_bytes = reader.read("!Q")[0]
        obj.tx_bytes = reader.read("!Q")[0]
        obj.rx_dropped = reader.read("!Q")[0]
        obj.tx_dropped = reader.read("!Q")[0]
        obj.rx_errors = reader.read("!Q")[0]
        obj.tx_errors = reader.read("!Q")[0]
        obj.rx_frame_err = reader.read("!Q")[0]
        obj.rx_over_err = reader.read("!Q")[0]
        obj.rx_crc_err = reader.read("!Q")[0]
        obj.collisions = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.rx_packets != other.rx_packets: return False
        if self.tx_packets != other.tx_packets: return False
        if self.rx_bytes != other.rx_bytes: return False
        if self.tx_bytes != other.tx_bytes: return False
        if self.rx_dropped != other.rx_dropped: return False
        if self.tx_dropped != other.tx_dropped: return False
        if self.rx_errors != other.rx_errors: return False
        if self.tx_errors != other.tx_errors: return False
        if self.rx_frame_err != other.rx_frame_err: return False
        if self.rx_over_err != other.rx_over_err: return False
        if self.rx_crc_err != other.rx_crc_err: return False
        return self.collisions == other.collisions

    def pretty_print(self, q):
        q.text("port_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("rx_packets = ");
                q.text("%#x" % self.rx_packets)
                q.text(","); q.breakable()
                q.text("tx_packets = ");
                q.text("%#x" % self.tx_packets)
                q.text(","); q.breakable()
                q.text("rx_bytes = ");
                q.text("%#x" % self.rx_bytes)
                q.text(","); q.breakable()
                q.text("tx_bytes = ");
                q.text("%#x" % self.tx_bytes)
                q.text(","); q.breakable()
                q.text("rx_dropped = ");
                q.text("%#x" % self.rx_dropped)
                q.text(","); q.breakable()
                q.text("tx_dropped = ");
                q.text("%#x" % self.tx_dropped)
                q.text(","); q.breakable()
                q.text("rx_errors = ");
                q.text("%#x" % self.rx_errors)
                q.text(","); q.breakable()
                q.text("tx_errors = ");
                q.text("%#x" % self.tx_errors)
                q.text(","); q.breakable()
                q.text("rx_frame_err = ");
                q.text("%#x" % self.rx_frame_err)
                q.text(","); q.breakable()
                q.text("rx_over_err = ");
                q.text("%#x" % self.rx_over_err)
                q.text(","); q.breakable()
                q.text("rx_crc_err = ");
                q.text("%#x" % self.rx_crc_err)
                q.text(","); q.breakable()
                q.text("collisions = ");
                q.text("%#x" % self.collisions)
            q.breakable()
        q.text('}')


class queue_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        self.type = type if type != None else 0
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.extend((struct.pack("!H", 0), '\x00' * 4))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        if subclass := queue_prop.subtypes.get(subtype):
            return subclass.unpack(reader)

        obj = queue_prop()
        obj.type = reader.read("!H")[0]
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        return obj

    def __eq__(self, other):
        return False if type(self) != type(other) else self.type == other.type

    def pretty_print(self, q):
        q.text("queue_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class queue_prop_experimenter(queue_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, data=None):
        self.experimenter = experimenter if experimenter != None else 0
        self.data = data if data != None else ''
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.extend((struct.pack("!H", 0), '\x00' * 4))
        packed.extend((struct.pack("!L", self.experimenter), '\x00' * 4))
        packed.append(self.data)
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 8)
        if subclass := queue_prop_experimenter.subtypes.get(subtype):
            return subclass.unpack(reader)

        obj = queue_prop_experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.experimenter = reader.read("!L")[0]
        reader.skip(4)
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        return self.data == other.data

    def pretty_print(self, q):
        q.text("queue_prop_experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

queue_prop.subtypes[65535] = queue_prop_experimenter

class queue_prop_max_rate(queue_prop):
    type = 2

    def __init__(self, rate=None):
        self.rate = rate if rate != None else 0
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.extend((struct.pack("!H", 0), '\x00' * 4))
        packed.extend((struct.pack("!H", self.rate), '\x00' * 6))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_prop_max_rate()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.rate = reader.read("!H")[0]
        reader.skip(6)
        return obj

    def __eq__(self, other):
        return False if type(self) != type(other) else self.rate == other.rate

    def pretty_print(self, q):
        q.text("queue_prop_max_rate {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
            q.breakable()
        q.text('}')

queue_prop.subtypes[2] = queue_prop_max_rate

class queue_prop_min_rate(queue_prop):
    type = 1

    def __init__(self, rate=None):
        self.rate = rate if rate != None else 0
        return

    def pack(self):
        packed = [struct.pack("!H", self.type)]
        packed.extend((struct.pack("!H", 0), '\x00' * 4))
        packed.extend((struct.pack("!H", self.rate), '\x00' * 6))
        length = sum(len(x) for x in packed)
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_prop_min_rate()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.rate = reader.read("!H")[0]
        reader.skip(6)
        return obj

    def __eq__(self, other):
        return False if type(self) != type(other) else self.rate == other.rate

    def pretty_print(self, q):
        q.text("queue_prop_min_rate {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
            q.breakable()
        q.text('}')

queue_prop.subtypes[1] = queue_prop_min_rate

class queue_stats_entry(loxi.OFObject):

    def __init__(self, port_no=None, queue_id=None, tx_bytes=None, tx_packets=None, tx_errors=None):
        self.port_no = port_no if port_no != None else 0
        self.queue_id = queue_id if queue_id != None else 0
        self.tx_bytes = tx_bytes if tx_bytes != None else 0
        self.tx_packets = tx_packets if tx_packets != None else 0
        self.tx_errors = tx_errors if tx_errors != None else 0
        return

    def pack(self):
        packed = [util.pack_port_no(self.port_no)]
        packed.append(struct.pack("!L", self.queue_id))
        packed.append(struct.pack("!Q", self.tx_bytes))
        packed.append(struct.pack("!Q", self.tx_packets))
        packed.append(struct.pack("!Q", self.tx_errors))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_stats_entry()
        obj.port_no = util.unpack_port_no(reader)
        obj.queue_id = reader.read("!L")[0]
        obj.tx_bytes = reader.read("!Q")[0]
        obj.tx_packets = reader.read("!Q")[0]
        obj.tx_errors = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.port_no != other.port_no: return False
        if self.queue_id != other.queue_id: return False
        if self.tx_bytes != other.tx_bytes: return False
        if self.tx_packets != other.tx_packets: return False
        return self.tx_errors == other.tx_errors

    def pretty_print(self, q):
        q.text("queue_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("port_no = ");
                q.text(util.pretty_port(self.port_no))
                q.text(","); q.breakable()
                q.text("queue_id = ");
                q.text("%#x" % self.queue_id)
                q.text(","); q.breakable()
                q.text("tx_bytes = ");
                q.text("%#x" % self.tx_bytes)
                q.text(","); q.breakable()
                q.text("tx_packets = ");
                q.text("%#x" % self.tx_packets)
                q.text(","); q.breakable()
                q.text("tx_errors = ");
                q.text("%#x" % self.tx_errors)
            q.breakable()
        q.text('}')


class table_stats_entry(loxi.OFObject):

    def __init__(self, table_id=None, name=None, match=None, wildcards=None, write_actions=None, apply_actions=None, write_setfields=None, apply_setfields=None, metadata_match=None, metadata_write=None, instructions=None, config=None, max_entries=None, active_count=None, lookup_count=None, matched_count=None):
        self.table_id = table_id if table_id != None else 0
        self.name = name if name != None else ""
        self.match = match if match != None else util.init_match_bmap()
        self.wildcards = wildcards if wildcards != None else util.init_wc_bmap()
        self.write_actions = write_actions if write_actions != None else 0
        self.apply_actions = apply_actions if apply_actions != None else 0
        self.write_setfields = write_setfields if write_setfields != None else 0
        self.apply_setfields = apply_setfields if apply_setfields != None else 0
        self.metadata_match = metadata_match if metadata_match != None else 0
        self.metadata_write = metadata_write if metadata_write != None else 0
        self.instructions = instructions if instructions != None else 0
        self.config = config if config != None else 0
        self.max_entries = max_entries if max_entries != None else 0
        self.active_count = active_count if active_count != None else 0
        self.lookup_count = lookup_count if lookup_count != None else 0
        self.matched_count = matched_count if matched_count != None else 0
        return

    def pack(self):
        packed = [struct.pack("!B", self.table_id), '\x00' * 7]
        packed.append(struct.pack("!32s", self.name))
        packed.append(util.pack_match_bmap(self.match))
        packed.append(util.pack_wc_bmap(self.wildcards))
        packed.append(struct.pack("!L", self.write_actions))
        packed.append(struct.pack("!L", self.apply_actions))
        packed.append(struct.pack("!Q", self.write_setfields))
        packed.append(struct.pack("!Q", self.apply_setfields))
        packed.append(struct.pack("!Q", self.metadata_match))
        packed.append(struct.pack("!Q", self.metadata_write))
        packed.append(struct.pack("!L", self.instructions))
        packed.append(struct.pack("!L", self.config))
        packed.append(struct.pack("!L", self.max_entries))
        packed.append(struct.pack("!L", self.active_count))
        packed.append(struct.pack("!Q", self.lookup_count))
        packed.append(struct.pack("!Q", self.matched_count))
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_stats_entry()
        obj.table_id = reader.read("!B")[0]
        reader.skip(7)
        obj.name = reader.read("!32s")[0].rstrip("\x00")
        obj.match = util.unpack_match_bmap(reader)
        obj.wildcards = util.unpack_wc_bmap(reader)
        obj.write_actions = reader.read("!L")[0]
        obj.apply_actions = reader.read("!L")[0]
        obj.write_setfields = reader.read("!Q")[0]
        obj.apply_setfields = reader.read("!Q")[0]
        obj.metadata_match = reader.read("!Q")[0]
        obj.metadata_write = reader.read("!Q")[0]
        obj.instructions = reader.read("!L")[0]
        obj.config = reader.read("!L")[0]
        obj.max_entries = reader.read("!L")[0]
        obj.active_count = reader.read("!L")[0]
        obj.lookup_count = reader.read("!Q")[0]
        obj.matched_count = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.table_id != other.table_id: return False
        if self.name != other.name: return False
        if self.match != other.match: return False
        if self.wildcards != other.wildcards: return False
        if self.write_actions != other.write_actions: return False
        if self.apply_actions != other.apply_actions: return False
        if self.write_setfields != other.write_setfields: return False
        if self.apply_setfields != other.apply_setfields: return False
        if self.metadata_match != other.metadata_match: return False
        if self.metadata_write != other.metadata_write: return False
        if self.instructions != other.instructions: return False
        if self.config != other.config: return False
        if self.max_entries != other.max_entries: return False
        if self.active_count != other.active_count: return False
        if self.lookup_count != other.lookup_count: return False
        return self.matched_count == other.matched_count

    def pretty_print(self, q):
        q.text("table_stats_entry {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("name = ");
                q.pp(self.name)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("wildcards = ");
                q.pp(self.wildcards)
                q.text(","); q.breakable()
                q.text("write_actions = ");
                q.text("%#x" % self.write_actions)
                q.text(","); q.breakable()
                q.text("apply_actions = ");
                q.text("%#x" % self.apply_actions)
                q.text(","); q.breakable()
                q.text("write_setfields = ");
                q.text("%#x" % self.write_setfields)
                q.text(","); q.breakable()
                q.text("apply_setfields = ");
                q.text("%#x" % self.apply_setfields)
                q.text(","); q.breakable()
                q.text("metadata_match = ");
                q.text("%#x" % self.metadata_match)
                q.text(","); q.breakable()
                q.text("metadata_write = ");
                q.text("%#x" % self.metadata_write)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.text("%#x" % self.instructions)
                q.text(","); q.breakable()
                q.text("config = ");
                q.text("%#x" % self.config)
                q.text(","); q.breakable()
                q.text("max_entries = ");
                q.text("%#x" % self.max_entries)
                q.text(","); q.breakable()
                q.text("active_count = ");
                q.text("%#x" % self.active_count)
                q.text(","); q.breakable()
                q.text("lookup_count = ");
                q.text("%#x" % self.lookup_count)
                q.text(","); q.breakable()
                q.text("matched_count = ");
                q.text("%#x" % self.matched_count)
            q.breakable()
        q.text('}')



match = match_v3
